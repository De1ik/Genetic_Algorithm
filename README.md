<h1>Evolutionary algorithm: Treasure Hunter</h1>
<p>Let's have a treasure hunter who moves in a world defined by a two-dimensional grid (see figure) and collects the treasures he finds along the way. He starts at the square marked S and can move in four different directions: up H, down D, right P and left L. He has a finite number of steps. His task is to collect as many treasures as possible. Only a position where the finder and the treasure are on the same square is considered to have found the treasure. Adjacent squares are not taken into account. </p>
![The example of the possible map](https://github.com/user-attachments/assets/af4f0bbc-7ad2-47d9-99ac-80029af0dd1a)

<h2>Assignment</h2>
<p>Solve the above problem through evolutionary programming over a virtual machine.</p>

<p>This specific method of evolutionary programming uses shared memory for data and instructions. The memory is initially zeroed and filled from the first cell with instructions. Initialization data (if any is needed) is stored after the program or from a specified location. After initialization, the program starts executing from the first memory cell. (The first cell is, of course, the cell with address 000000.) Instructions modify memory cells, can perform branching, program jumps, read some data from the input, and possibly write to the output. The program ends with an instruction to stop, after a specified number of steps, on an incorrect instruction, after a complete or incorrect output. The quality of the program is evaluated by the output produced or, when the program does not write to the output, by the resulting state of the specified memory cells.</p>

<h2>Virtual machine</h2>
<p>Virtual machine will have 64 memory cells of size 1 byte.</p>
<p>It will know four instructions: increment the memory cell value, decrement the memory cell value, jump to the address, and dump (H, D, P, or L) according to the memory cell value. The instructions are in the form of the following table:</p>
<table>
    <tr>
        <th>inštrukcia</th>
        <th>tvar</th>
    </tr>
    <tr>
        <td>inkrementácia</td>
        <td>00XXXXXXXX</td>
    </tr>
    <tr>
        <td>dekrementácia</td>
        <td>01XXXXXXXX</td>
    </tr>
    <tr>
        <td>skok</td>
        <td>10XXXXXXXX</td>
    </tr>
    <tr>
        <td>výpis</td>
        <td>11XXXXXXXX</td>
    </tr>
</table>

<p>The value XXXXXX represents the 6-bit address of the memory cell that the instruction is working with (so each one can be addressed). The first three instructions should be clear, for the last one it is necessary to define what will be printed at what cell value. For example, if it contains a maximum of two units it will be H, for three and four it will be D, for five and six it will be P, and for seven and eight units in the memory cell it will be L. As a demonstration, let us take a simple example:</p>
<table>
    <tr>
        <th>Adresa:</th>
        <td>000000</td>
        <td>000001</td>
        <td>000010</td>
        <td>000011</td>
        <td>000100</td>
        <td>000101</td>
        <td>000110</td>
        <td>...</td>
    </tr>
    <tr>
        <th>Hodnota:</th>
        <td>00000000</td>
        <td>00011111</td>
        <td>00010000</td>
        <td>01010000</td>
        <td>00000101</td>
        <td>11000000</td>
        <td>10000100</td>
        <td>...</td>
    </tr>
</table>

<p>The output of this program will be a sequence: P H H H H D H ... The next values will depend on the values of the following memory cells. (I hope it is clear that the above sequence is output by the instruction in memory cell with address 5. And the program is self-modifying, so the values printed do not correspond to the values at the beginning, but while the program is running.) This is better seen in a simple simulation. Better representations of the values for H D P and L are possible (and recommended), for example by the last two bits.</p>
<p>The program will stop as soon as any of the following conditions are met:</p>
<ul>
  <li>the program has found all the treasures </li>
  <li>the sequence generated by the program deviated from the specified grid </li>
  <li>the program has executed 500 steps (instructions) </li>
</ul>


